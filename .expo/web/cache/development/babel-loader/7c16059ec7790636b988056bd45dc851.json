{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport Text from \"react-native-web/dist/exports/Text\";\nimport TouchableOpacity from \"react-native-web/dist/exports/TouchableOpacity\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport MatrixMath from 'react-native/Libraries/Utilities/MatrixMath';\nimport styles from \"./Styles\";\n\nfunction transformOrigin(matrix, origin) {\n  var x = origin.x,\n      y = origin.y,\n      z = origin.z;\n  var translate = MatrixMath.createIdentityMatrix();\n  MatrixMath.reuseTranslate3dCommand(translate, x, y, z);\n  MatrixMath.multiplyInto(matrix, translate, matrix);\n  var untranslate = MatrixMath.createIdentityMatrix();\n  MatrixMath.reuseTranslate3dCommand(untranslate, -x, -y, -z);\n  MatrixMath.multiplyInto(matrix, matrix, untranslate);\n}\n\nfunction createTranslateXScaleX(scaleXFactor, x) {\n  return [scaleXFactor, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, 0, 0, 1];\n}\n\nvar TabBar = function (_Component) {\n  _inherits(TabBar, _Component);\n\n  var _super = _createSuper(TabBar);\n\n  function TabBar() {\n    var _this;\n\n    _classCallCheck(this, TabBar);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.initialSetupWasDone = false;\n    _this.currentContentOffset = {\n      x: 0,\n      y: 0\n    };\n    _this.tabState = {};\n    _this.tabContainerLayout = {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0\n    };\n    _this.scrollContainerLayout = {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0\n    };\n    _this.underlineRef = null;\n    _this.scrollView = null;\n    _this._animateListenerId = null;\n    _this.offsetCollection = null;\n    _this.widthCollection = null;\n    _this.scrollOffsetsCollection = null;\n    _this.state = {\n      renderUnderline: false,\n      tabScrollValue: 0\n    };\n\n    _this.measureTabsContainer = function (event) {\n      _this.tabContainerLayout = event.nativeEvent.layout;\n\n      _this.checkMeasures();\n    };\n\n    _this.onScrollContentSizeChange = function (width, height) {\n      _this.scrollContainerLayout = {\n        width: width,\n        height: height,\n        x: 0,\n        y: 0\n      };\n\n      _this.checkMeasures();\n    };\n\n    _this.setUnderlineRef = function (ref) {\n      _this.underlineRef = ref;\n    };\n\n    _this.handleScrolling = function (event) {\n      var value = event.value;\n      var dx = _this.offsetCollection && _this.offsetCollection._interpolation(value) || 0;\n      var scaleX = _this.widthCollection && _this.widthCollection._interpolation(value) || 0;\n\n      _this.applyTransformToUnderline(scaleX, dx);\n\n      if (_this.scrollOffsetsCollection) {\n        var scrollOffset = _this.scrollOffsetsCollection && _this.scrollOffsetsCollection._interpolation(value);\n\n        if (_this.scrollView) {\n          _this.scrollView.scrollTo({\n            x: scrollOffset,\n            animated: false\n          });\n        }\n      }\n    };\n\n    _this.checkMeasures = function () {\n      if (_this.state.renderUnderline && _this.tabContainerLayout.width !== 0 && _this.scrollContainerLayout.width !== 0) {\n        _this.calculateInterpolations();\n\n        if (!_this.initialSetupWasDone) {\n          var activeTab = _this.props.activeTab;\n\n          _this.handleScrolling({\n            value: activeTab\n          });\n\n          _this.initialSetupWasDone = true;\n        }\n      }\n    };\n\n    _this.calculateInterpolations = function () {\n      var inputRange = Object.keys(_this.tabState).map(Number);\n      var outputRangeLeft = [];\n      var outputRangeWidth = [];\n      var tabContainerWidth = _this.tabContainerLayout.width;\n      var scrollWidth = _this.scrollContainerLayout.width;\n      var marginValue = _this.props.tabMargin;\n\n      for (var i = 0, len = inputRange.length; i < len; i += 1) {\n        var key = inputRange[i];\n        outputRangeLeft.push(_this.tabState[key].x);\n        outputRangeWidth.push(_this.tabState[key].width);\n      }\n\n      if (inputRange.length < 2) {\n        inputRange.push(1);\n        outputRangeLeft.push(0);\n        outputRangeWidth.push(0);\n      }\n\n      _this.offsetCollection = _this.props.scrollValue.interpolate({\n        inputRange: inputRange,\n        outputRange: outputRangeLeft\n      });\n      _this.widthCollection = _this.props.scrollValue.interpolate({\n        inputRange: inputRange,\n        outputRange: outputRangeWidth\n      });\n      var outputRangeScroll = [0];\n\n      for (var _i = 1, _len2 = inputRange.length; _i < _len2; _i += 1) {\n        var isLast = _i === _len2 - 1;\n        var offset = outputRangeLeft[_i];\n        var tabWidth = outputRangeWidth[_i];\n        var nextTabWidth = outputRangeWidth[_i + 1] || 0;\n        var scrollOffset = offset;\n\n        if (offset + tabWidth + nextTabWidth + 2 * marginValue >= scrollWidth) {\n          if (isLast) {\n            scrollOffset = offset - (tabContainerWidth - (tabWidth + marginValue));\n          } else {\n            scrollOffset = offset - (tabContainerWidth - (tabWidth + nextTabWidth + 1.3 * marginValue));\n          }\n        } else {\n          scrollOffset = offset - (tabContainerWidth - (tabWidth + marginValue) + (nextTabWidth + 2 * marginValue)) / 2;\n          scrollOffset = scrollOffset >= 0 ? scrollOffset : 0;\n        }\n\n        outputRangeScroll.push(scrollOffset);\n      }\n\n      if (scrollWidth <= tabContainerWidth) {\n        _this.scrollOffsetsCollection = _this.props.scrollValue.interpolate({\n          inputRange: [-1, 0],\n          outputRange: [-40, 0],\n          extrapolate: 'clamp'\n        });\n        return;\n      }\n\n      _this.scrollOffsetsCollection = _this.props.scrollValue.interpolate({\n        inputRange: [-1].concat(_toConsumableArray(inputRange)),\n        outputRange: [-40].concat(outputRangeScroll)\n      });\n    };\n\n    _this.onTabBarScrolling = function (e) {\n      _this.currentContentOffset = e.nativeEvent.contentOffset;\n    };\n\n    _this.renderTab = function (tab, page, isTabActive, onPressHandler, onTabLayout) {\n      var _this$props = _this.props,\n          tabBadgeColor = _this$props.tabBadgeColor,\n          activeTabTextStyle = _this$props.activeTabTextStyle;\n      var label = tab.label,\n          badge = tab.badge,\n          badgeColor = tab.badgeColor;\n      var activeTextColor = _this.props.activeTextColor || 'navy';\n      var inactiveTextColor = _this.props.inactiveTextColor || 'black';\n      var textStyle = _this.props.tabBarTextStyle;\n      return React.createElement(TouchableOpacity, {\n        style: [styles.tab, _this.props.tabMargin && {\n          marginLeft: _this.props.tabMargin\n        }, _this.props.tabStyles.tab],\n        key: page,\n        onPress: onPressHandler,\n        onLayout: onTabLayout\n      }, React.createElement(Text, {\n        style: [{\n          color: isTabActive ? activeTextColor : inactiveTextColor\n        }, textStyle, isTabActive && activeTabTextStyle]\n      }, label), badge != null && parseInt(badge, 10) > 0 && React.createElement(View, {\n        style: [styles.badgeBubble, _this.props.tabStyles.badgeBubble, {\n          backgroundColor: badgeColor || tabBadgeColor || activeTextColor\n        }]\n      }, React.createElement(Text, {\n        style: [styles.badgeText, _this.props.tabStyles.badgeText]\n      }, badge)));\n    };\n\n    return _this;\n  }\n\n  _createClass(TabBar, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this._animateListenerId = this.props.scrollValue.addListener(this.handleScrolling);\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      var serializedState = JSON.stringify(this.props) + JSON.stringify(this.state);\n      var serializedNextState = JSON.stringify(nextProps) + JSON.stringify(nextState);\n      return serializedState !== serializedNextState;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._animateListenerId) {\n        this.props.scrollValue.removeListener(this._animateListenerId);\n      }\n    }\n  }, {\n    key: \"applyTransformToUnderline\",\n    value: function applyTransformToUnderline(scaleXFactor, dx) {\n      var underlineRef = this.underlineRef;\n      if (!underlineRef) return;\n      var matrix = createTranslateXScaleX(scaleXFactor, dx);\n      transformOrigin(matrix, {\n        x: -0.5,\n        y: 0,\n        z: 0\n      });\n      underlineRef.setNativeProps({\n        style: {\n          transform: [{\n            matrix: matrix\n          }]\n        }\n      });\n    }\n  }, {\n    key: \"onTabLayout\",\n    value: function onTabLayout(event, page) {\n      var _this2 = this;\n\n      var _event$nativeEvent$la = event.nativeEvent.layout,\n          x = _event$nativeEvent$la.x,\n          y = _event$nativeEvent$la.y,\n          width = _event$nativeEvent$la.width,\n          height = _event$nativeEvent$la.height;\n      this.tabState[page] = {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      };\n\n      if (this.state.renderUnderline) {\n        this.calculateInterpolations();\n        this.setState({\n          renderUnderline: false\n        }, function () {\n          _this2.setState({\n            renderUnderline: true\n          }, function () {\n            _this2.handleScrolling({\n              value: _this2.props.scrollValue.__getValue()\n            });\n          });\n        });\n        return;\n      }\n\n      if (this.props.tabs.length === Object.keys(this.tabState).length) {\n        this.setState({\n          renderUnderline: true\n        }, this.checkMeasures);\n      }\n    }\n  }, {\n    key: \"renderUnderline\",\n    value: function renderUnderline() {\n      var tabUnderlineStyle = {\n        position: 'absolute',\n        backgroundColor: this.props.underlineColor,\n        height: this.props.underlineHeight,\n        width: 1,\n        bottom: this.props.underlineBottomPosition,\n        padding: 0\n      };\n      return React.createElement(Animated.View, {\n        ref: this.setUnderlineRef,\n        style: [tabUnderlineStyle]\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var _this$props2 = this.props,\n          style = _this$props2.style,\n          backgroundColor = _this$props2.backgroundColor,\n          tabBarStyle = _this$props2.tabBarStyle,\n          tabMargin = _this$props2.tabMargin,\n          scrollContainerStyle = _this$props2.scrollContainerStyle,\n          tabs = _this$props2.tabs;\n      return React.createElement(View, {\n        style: [styles.tabs, {\n          backgroundColor: backgroundColor\n        }, style, tabBarStyle],\n        onLayout: this.measureTabsContainer\n      }, React.createElement(ScrollView, {\n        horizontal: true,\n        contentContainerStyle: [styles.scrollContainer, tabMargin && {\n          paddingRight: tabMargin\n        }, scrollContainerStyle],\n        showsHorizontalScrollIndicator: false,\n        onContentSizeChange: this.onScrollContentSizeChange,\n        ref: function ref(node) {\n          return _this3.scrollView = node;\n        },\n        bounces: false,\n        scrollEventThrottle: 1,\n        onScroll: this.onTabBarScrolling\n      }, tabs.map(function (tab, page) {\n        var renderTab = _this3.props.renderTab || _this3.renderTab;\n        var isTabActive = _this3.props.activeTab === page;\n\n        var onPressHandler = function onPressHandler() {\n          return _this3.props.goToPage(page);\n        };\n\n        var onTabLayout = function onTabLayout(event) {\n          return _this3.onTabLayout(event, page);\n        };\n\n        return renderTab(tab, page, isTabActive, onPressHandler, onTabLayout);\n      }), this.state.renderUnderline && this.renderUnderline()));\n    }\n  }]);\n\n  return TabBar;\n}(Component);\n\nTabBar.defaultProps = {\n  tabMargin: 20,\n  tabBarTextStyle: {},\n  tabStyles: {\n    tab: {},\n    badgeBubble: {},\n    badgeText: {}\n  },\n  scrollContainerStyle: {},\n  style: {},\n  underlineColor: 'navy',\n  underlineHeight: 2,\n  underlineBottomPosition: 0\n};\nexport default TabBar;","map":{"version":3,"sources":["D:/Work_Learn/react-native/learningapp2/node_modules/react-native-underline-tabbar/lib/TabBar.js"],"names":["React","Component","MatrixMath","styles","transformOrigin","matrix","origin","x","y","z","translate","createIdentityMatrix","reuseTranslate3dCommand","multiplyInto","untranslate","createTranslateXScaleX","scaleXFactor","TabBar","initialSetupWasDone","currentContentOffset","tabState","tabContainerLayout","width","height","scrollContainerLayout","underlineRef","scrollView","_animateListenerId","offsetCollection","widthCollection","scrollOffsetsCollection","state","renderUnderline","tabScrollValue","measureTabsContainer","event","nativeEvent","layout","checkMeasures","onScrollContentSizeChange","setUnderlineRef","ref","handleScrolling","value","dx","_interpolation","scaleX","applyTransformToUnderline","scrollOffset","scrollTo","animated","calculateInterpolations","activeTab","props","inputRange","Object","keys","map","Number","outputRangeLeft","outputRangeWidth","tabContainerWidth","scrollWidth","marginValue","tabMargin","i","len","length","key","push","scrollValue","interpolate","outputRange","outputRangeScroll","isLast","offset","tabWidth","nextTabWidth","extrapolate","onTabBarScrolling","e","contentOffset","renderTab","tab","page","isTabActive","onPressHandler","onTabLayout","tabBadgeColor","activeTabTextStyle","label","badge","badgeColor","activeTextColor","inactiveTextColor","textStyle","tabBarTextStyle","marginLeft","tabStyles","color","parseInt","badgeBubble","backgroundColor","badgeText","addListener","nextProps","nextState","serializedState","JSON","stringify","serializedNextState","removeListener","setNativeProps","style","transform","setState","__getValue","tabs","tabUnderlineStyle","position","underlineColor","underlineHeight","bottom","underlineBottomPosition","padding","tabBarStyle","scrollContainerStyle","scrollContainer","paddingRight","node","goToPage","defaultProps"],"mappings":"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","sourcesContent":["/**\n * Created by Konstantin Yakushin.\n * react-native-underline-tabbar\n */\n// @flow\nimport React, { Component } from 'react';\nimport { Text, TouchableOpacity, View, Animated, ScrollView } from 'react-native';\nimport MatrixMath from 'react-native/Libraries/Utilities/MatrixMath';\n\nimport styles from './Styles';\n\nfunction transformOrigin(matrix, origin) {\n  const { x, y, z } = origin;\n\n  const translate = MatrixMath.createIdentityMatrix();\n  MatrixMath.reuseTranslate3dCommand(translate, x, y, z);\n  MatrixMath.multiplyInto(matrix, translate, matrix);\n\n  const untranslate = MatrixMath.createIdentityMatrix();\n  MatrixMath.reuseTranslate3dCommand(untranslate, -x, -y, -z);\n  MatrixMath.multiplyInto(matrix, matrix, untranslate);\n}\n\nfunction createTranslateXScaleX(scaleXFactor, x) {\n  // prettier-ignore\n  return [\n    scaleXFactor, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    x, 0, 0, 1,\n  ];\n}\n\nexport type TabType = {\n  label: string,\n  badge: string,\n  badgeColor?: string,\n  [string]: any,\n};\n\nexport type Props = {\n  goToPage: Function,\n  activeTab: number,\n  tabs: TabType[],\n  underlineColor: string,\n  underlineHeight: number,\n  underlineBottomPosition: number,\n  backgroundColor: string,\n  activeTextColor: string,\n  inactiveTextColor: string,\n  tabBadgeColor: string,\n  scrollValue: Animated.Value,\n  scrollContainerStyle: Object,\n  tabStyles: {\n    tab?: Object,\n    badgeBubble?: Object,\n    badgeText?: Object,\n  },\n  tabMargin: number,\n  style: Object,\n  activeTabTextStyle: Object,\n  tabBarTextStyle: Object,\n  tabBarStyle: Object,\n  renderTab: (\n    tab: TabType,\n    page: number,\n    isTabActive: boolean,\n    onPressHandler: Function,\n    onTabLayout: Function,\n  ) => any,\n};\n\ntype State = {\n  renderUnderline: boolean,\n  tabScrollValue: number,\n};\n\ntype LayoutType = {\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n};\n\ntype TabStateType = {\n  [string | number]: LayoutType,\n};\n\nclass TabBar extends Component<Props, State> {\n  static defaultProps = {\n    tabMargin: 20,\n    tabBarTextStyle: {},\n    tabStyles: {\n      tab: {},\n      badgeBubble: {},\n      badgeText: {},\n    },\n    scrollContainerStyle: {},\n    style: {},\n    underlineColor: 'navy',\n    underlineHeight: 2,\n    underlineBottomPosition: 0,\n  };\n  initialSetupWasDone: boolean = false;\n  currentContentOffset: { y: number, x: number } = { x: 0, y: 0 };\n  tabState: TabStateType = {};\n  tabContainerLayout: LayoutType = {\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0,\n  };\n  scrollContainerLayout: LayoutType = {\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0,\n  };\n  underlineRef: ?any = null;\n  scrollView: ?any = null;\n  _animateListenerId: ?string = null;\n  offsetCollection: ?Object = null;\n  widthCollection: ?Object = null;\n  scrollOffsetsCollection: ?Object = null;\n  state = {\n    renderUnderline: false,\n    tabScrollValue: 0,\n  };\n\n  componentDidMount() {\n    this._animateListenerId = this.props.scrollValue.addListener(this.handleScrolling);\n  }\n\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\n    const serializedState = JSON.stringify(this.props) + JSON.stringify(this.state);\n    const serializedNextState = JSON.stringify(nextProps) + JSON.stringify(nextState);\n    return serializedState !== serializedNextState;\n  }\n\n  componentWillUnmount() {\n    if (this._animateListenerId) {\n      this.props.scrollValue.removeListener(this._animateListenerId);\n    }\n  }\n\n  measureTabsContainer = (event: Object) => {\n    this.tabContainerLayout = event.nativeEvent.layout;\n    this.checkMeasures();\n  };\n\n  onScrollContentSizeChange = (width: number, height: number) => {\n    this.scrollContainerLayout = { width, height, x: 0, y: 0 };\n    this.checkMeasures();\n  };\n\n  setUnderlineRef = (ref: any) => {\n    this.underlineRef = ref;\n  };\n\n  handleScrolling = (event: { value: number }) => {\n    const { value } = event;\n    const dx = (this.offsetCollection && this.offsetCollection._interpolation(value)) || 0;\n    const scaleX = (this.widthCollection && this.widthCollection._interpolation(value)) || 0;\n    this.applyTransformToUnderline(scaleX, dx);\n    if (this.scrollOffsetsCollection) {\n      const scrollOffset =\n        this.scrollOffsetsCollection && this.scrollOffsetsCollection._interpolation(value);\n      if (this.scrollView) {\n        this.scrollView.scrollTo({ x: scrollOffset, animated: false });\n      }\n    }\n  };\n\n  applyTransformToUnderline(scaleXFactor: number, dx: number) {\n    const { underlineRef } = this;\n    if (!underlineRef) return;\n    const matrix = createTranslateXScaleX(scaleXFactor, dx);\n    transformOrigin(matrix, { x: -0.5, y: 0, z: 0 });\n    underlineRef.setNativeProps({\n      style: {\n        transform: [\n          {\n            matrix,\n          },\n        ],\n      },\n    });\n  }\n\n  onTabLayout(event: Object, page: number) {\n    const { x, y, width, height } = event.nativeEvent.layout;\n    this.tabState[page] = { x, y, width, height };\n    if (this.state.renderUnderline) {\n      this.calculateInterpolations();\n      // The next lines may look awful and it will be true\n      // But they are needed to update underline without glitches\n      // FIXME: Find another way to rerender update underline without glitches\n      this.setState({ renderUnderline: false }, () => {\n        this.setState({ renderUnderline: true }, () => {\n          this.handleScrolling({ value: this.props.scrollValue.__getValue() });\n        });\n      });\n      return;\n    }\n    if (this.props.tabs.length === Object.keys(this.tabState).length) {\n      this.setState({ renderUnderline: true }, this.checkMeasures);\n    }\n  }\n\n  checkMeasures = () => {\n    if (\n      this.state.renderUnderline &&\n      this.tabContainerLayout.width !== 0 &&\n      this.scrollContainerLayout.width !== 0\n    ) {\n      this.calculateInterpolations();\n      if (!this.initialSetupWasDone) {\n        const { activeTab } = this.props;\n        this.handleScrolling({ value: activeTab });\n        this.initialSetupWasDone = true;\n      }\n    }\n  };\n\n  calculateInterpolations = () => {\n    const inputRange = Object.keys(this.tabState).map(Number);\n    const outputRangeLeft = [];\n    const outputRangeWidth = [];\n    const tabContainerWidth = this.tabContainerLayout.width;\n    const scrollWidth = this.scrollContainerLayout.width;\n    const marginValue = this.props.tabMargin;\n    for (let i = 0, len = inputRange.length; i < len; i += 1) {\n      const key = inputRange[i];\n      outputRangeLeft.push(this.tabState[key].x);\n      outputRangeWidth.push(this.tabState[key].width);\n    }\n    // Serve the case when we have only one tab\n    // Also it doesn't make sense to handle case when we don't have tabs at all\n    // because ScrollableTabView wouldn't work\n    if (inputRange.length < 2) {\n      inputRange.push(1);\n      outputRangeLeft.push(0);\n      outputRangeWidth.push(0);\n    }\n    // $FlowFixMe\n    this.offsetCollection = this.props.scrollValue.interpolate({\n      inputRange, // $FlowFixMe\n      outputRange: outputRangeLeft, // $FlowFixMe\n    });\n    // $FlowFixMe\n    this.widthCollection = this.props.scrollValue.interpolate({\n      inputRange, // $FlowFixMe\n      outputRange: outputRangeWidth, // $FlowFixMe\n    });\n    const outputRangeScroll = [0];\n    for (let i = 1, len = inputRange.length; i < len; i += 1) {\n      const isLast = i === len - 1;\n      const offset = outputRangeLeft[i];\n      const tabWidth = outputRangeWidth[i];\n      const nextTabWidth = outputRangeWidth[i + 1] || 0;\n      let scrollOffset = offset;\n\n      if (offset + tabWidth + nextTabWidth + 2 * marginValue >= scrollWidth) {\n        if (isLast) {\n          scrollOffset = offset - (tabContainerWidth - (tabWidth + marginValue));\n        } else {\n          // 1.3 - is a magical constant\n          // actually it is just 1.3 of margins. If to place 2\n          // scrollOffset will match with last tab's offset\n          // And it will prevent bounce effect while scrolling\n          scrollOffset =\n            offset - (tabContainerWidth - (tabWidth + nextTabWidth + 1.3 * marginValue));\n        }\n      } else {\n        scrollOffset =\n          offset -\n          (tabContainerWidth - (tabWidth + marginValue) + (nextTabWidth + 2 * marginValue)) / 2;\n        scrollOffset = scrollOffset >= 0 ? scrollOffset : 0;\n      }\n      outputRangeScroll.push(scrollOffset);\n    }\n    if (scrollWidth <= tabContainerWidth) {\n      this.scrollOffsetsCollection = this.props.scrollValue.interpolate({\n        inputRange: [-1, 0], // $FlowFixMe\n        outputRange: [-40, 0], // $FlowFixMe\n        extrapolate: 'clamp', // $FlowFixMe\n      });\n      return;\n    }\n    // $FlowFixMe\n    this.scrollOffsetsCollection = this.props.scrollValue.interpolate({\n      inputRange: [-1, ...inputRange], // $FlowFixMe\n      outputRange: [-40, ...outputRangeScroll], // $FlowFixMe\n    });\n  };\n\n  onTabBarScrolling = (e: Object) => {\n    this.currentContentOffset = e.nativeEvent.contentOffset;\n  };\n\n  renderUnderline() {\n    const tabUnderlineStyle = {\n      position: 'absolute',\n      backgroundColor: this.props.underlineColor,\n      height: this.props.underlineHeight,\n      width: 1,\n      bottom: this.props.underlineBottomPosition,\n      padding: 0,\n    };\n\n    return <Animated.View ref={this.setUnderlineRef} style={[tabUnderlineStyle]} />;\n  }\n\n  renderTab = (\n    tab: TabType,\n    page: number,\n    isTabActive: boolean,\n    onPressHandler: Function,\n    onTabLayout: Function,\n  ) => {\n    const { tabBadgeColor, activeTabTextStyle } = this.props;\n    const { label, badge, badgeColor } = tab;\n    const activeTextColor = this.props.activeTextColor || 'navy';\n    const inactiveTextColor = this.props.inactiveTextColor || 'black';\n    const textStyle = this.props.tabBarTextStyle;\n    return (\n      <TouchableOpacity\n        style={[\n          styles.tab,\n          this.props.tabMargin && { marginLeft: this.props.tabMargin },\n          this.props.tabStyles.tab,\n        ]}\n        key={page}\n        onPress={onPressHandler}\n        onLayout={onTabLayout}\n      >\n        <Text\n          style={[\n            { color: isTabActive ? activeTextColor : inactiveTextColor },\n            textStyle,\n            isTabActive && activeTabTextStyle,\n          ]}\n        >\n          {label}\n        </Text>\n        {badge != null &&\n        (parseInt(badge, 10) > 0) && (\n          <View\n            style={[\n              styles.badgeBubble,\n              this.props.tabStyles.badgeBubble,\n              { backgroundColor: badgeColor || tabBadgeColor || activeTextColor },\n            ]}\n          >\n            <Text style={[styles.badgeText, this.props.tabStyles.badgeText]}>{badge}</Text>\n          </View>\n        )}\n      </TouchableOpacity>\n    );\n  };\n\n  render() {\n    const {\n      style,\n      backgroundColor,\n      tabBarStyle,\n      tabMargin,\n      scrollContainerStyle,\n      tabs,\n    } = this.props;\n    return (\n      <View\n        style={[styles.tabs, { backgroundColor }, style, tabBarStyle]}\n        onLayout={this.measureTabsContainer}\n      >\n        <ScrollView\n          horizontal\n          contentContainerStyle={[\n            styles.scrollContainer,\n            tabMargin && { paddingRight: tabMargin },\n            scrollContainerStyle,\n          ]}\n          showsHorizontalScrollIndicator={false}\n          onContentSizeChange={this.onScrollContentSizeChange}\n          ref={node => (this.scrollView = node)}\n          bounces={false}\n          scrollEventThrottle={1}\n          onScroll={this.onTabBarScrolling}\n        >\n          {tabs.map((tab: TabType, page: number) => {\n            const renderTab = this.props.renderTab || this.renderTab;\n            const isTabActive = this.props.activeTab === page;\n            const onPressHandler = () => this.props.goToPage(page);\n            const onTabLayout = (event: Object) => this.onTabLayout(event, page);\n            return renderTab(tab, page, isTabActive, onPressHandler, onTabLayout);\n          })}\n          {this.state.renderUnderline && this.renderUnderline()}\n        </ScrollView>\n      </View>\n    );\n  }\n}\n\nexport default TabBar;\n"]},"metadata":{},"sourceType":"module"}